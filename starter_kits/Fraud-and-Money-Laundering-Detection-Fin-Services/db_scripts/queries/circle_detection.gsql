CREATE QUERY circle_detection (VERTEX<User> source_id)  FOR GRAPH AntiFraud SYNTAX v2 {
  /*
    This is an anti-money laundering query. It detects money flow circle from a starting user. 
 
    Given a user id "source_id", find all the transaction paths originated from the input user 
    and eventually come back to the user. The path length is limited from 3 to 6. 

    Sample input:
    source_id : any integer between 1 and 500.
  */
  
  TYPEDEF TUPLE<EDGE e, VERTEX v, DOUBLE amount, INT ts> Edge_Tuple;
  MinAccum<INT> @min_left_dist = GSQL_INT_MAX;
  MinAccum<INT> @min_right_dist = GSQL_INT_MAX;
  MinAccum<INT> @@min_src_send_time = GSQL_INT_MAX;
  MaxAccum<INT> @@max_src_receive_time = 0;
  OrAccum @is_valid = FALSE;// Flag used to record valid vertices in the subgraph
  
  // The following accumulators are used for aggregation on src
  SumAccum<INT> @sum_valid_trans_num = 0;
  SumAccum<INT> @sum_valid_trans_sum = 0;
  MaxAccum<INT> @max_rank = 0;
  ListAccum<ListAccum<Edge_Tuple>> @edge_tuple_list;
  ListAccum<ListAccum<Edge_Tuple>> @new_edge_tuple_list;
  ListAccum<ListAccum<Edge_Tuple>> @@circle_edge_tuples_list;
  OrAccum @receive_new_path = FALSE;

  // The following accumulators are used for printing edges and vertices
  SetAccum<vertex> @@vertex_set;
  ListAccum<ListAccum<Edge>> @@circle_paths_list;
  
  INT STEP_LOW_LIMIT = 3;
  INT STEP_HIGH_LIMIT = 6;
  INT HALF_STEP;
  INT STEP;
  
  // Starting from the input vertex user.
  Seed = {source_id};

  /* Prep: Find all trasactions related to the input user with edge User_Transfer_Transaction 
  or User_Receive_Transaction, and use one step to find out src's min_send_time and max_receive_time, 
  then initialize the distance info for source_id*/
  Seed = SELECT src
      FROM Seed:src - ((User_Transfer_Transaction>|User_Receive_Transaction>):e) - Transaction:tgt
      ACCUM
        CASE WHEN e.type == "User_Transfer_Transaction" 
            THEN @@min_src_send_time += tgt.ts
        ELSE
            @@max_src_receive_time += tgt.ts
        END
      POST-ACCUM
        src.@min_left_dist = 0,
        src.@min_right_dist = 0,
        src.@is_valid = TRUE
      /* Make sure that it has a loop, if @@max_src_receive_time < @@min_src_send_time, 
      then there is no loop because, if @@max_src_receive_time < @@min_src_send_time, 
      all the valid money it receives are before it sends out money.*/
      HAVING @@max_src_receive_time >= @@min_src_send_time;

  /* PRINT epoch_to_datetime(@@max_src_receive_time), epoch_to_datetime(@@min_src_send_time), startTime, endTime;
  Now start the bidirectional search of loops for source_id
  1) First bidirectional search for the potential subgraph for all loops of source_id
  2) Then one directional search to valid each path inside the subgraph using path filters, 
     i.e. time increase along the path*/

  // Set X and Y as Seed
  X (_) = Seed;//X is used to do positive direction traversal
  Y (_) = Seed;//Y is used to do negative direction traversal

  /* In order to do bidirectional search, we separate search into two steps,
   i) Search for half of total steps, only touch unmark vertices, 
     i.e. positive directional search only touch positive unmarked vertices,
         negative search only touch negative unmarked vertices
         
   ii) After the first half search, the following search only happens for marked vertices,
    i.e. positive directional search only touch negative marked and positive unmarked vertices,
         negative search only touch negative positive marked and negative unmarked vertices,
         if one of touched vertex fulfill the condition that positive distance + negative 
         distance < STEP_HIGH_LIMIT, it is a valid vertex*/
  
  // 1. First search for half of total steps 
  HALF_STEP = (STEP_HIGH_LIMIT + 1) / 2;
  STEP = 0;
  WHILE STEP <= HALF_STEP AND X.size() + Y.size() > 0 DO
      IF X.size() > 0 THEN
          // From User to Transaction
          X = SELECT tgt
              FROM X:src - (User_Transfer_Transaction>:e) - Transaction:tgt
              WHERE 
                // tgt.ts must be bigger than min_src_send_time so that all paths has increasing time
                tgt.ts >= @@min_src_send_time 
                AND src.@min_left_dist < GSQL_INT_MAX 
                AND tgt.@min_left_dist == GSQL_INT_MAX
              ACCUM tgt.@min_left_dist += src.@min_left_dist + 1               
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END;
          // From Transaction to User
          X = SELECT tgt
              FROM X:src - (<User_Receive_Transaction:e) - User:tgt
              WHERE src.@min_left_dist < GSQL_INT_MAX 
              // Only when tgt is not left visited, update the distance info
                AND tgt.@min_left_dist == GSQL_INT_MAX
              ACCUM tgt.@min_left_dist += src.@min_left_dist + 1               
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END
              HAVING tgt != source_id;
        END;

      IF Y.size() > 0 THEN
          // From User to Transaction
          Y = SELECT tgt
              FROM Y:src - (User_Receive_Transaction>:e) - Transaction:tgt
              WHERE
                tgt.ts <= @@max_src_receive_time 
                AND src.@min_right_dist < GSQL_INT_MAX 
                AND tgt.@min_right_dist == GSQL_INT_MAX
              ACCUM tgt.@min_right_dist += src.@min_right_dist + 1
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END;
          // From Transaction to User
          Y = SELECT tgt
             FROM Y:src - (<User_Transfer_Transaction:e) - User:tgt
             WHERE src.@min_right_dist < GSQL_INT_MAX 
               // Only when tgt is not left visited, update the distance info
               AND tgt.@min_right_dist == GSQL_INT_MAX
             ACCUM tgt.@min_right_dist += src.@min_right_dist + 1               
             POST-ACCUM
               CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                 AND tgt.@min_right_dist < GSQL_INT_MAX
                 AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
               THEN
                 tgt.@is_valid = TRUE
             END
             HAVING tgt != source_id;
      END;
      STEP = STEP + 1;
  END;
  
  // 2. Start the last half of search, only touch marked vertices
  WHILE STEP <= STEP_HIGH_LIMIT AND X.size() + Y.size() > 0 DO
      IF X.size() > 0 THEN
          // From User to Transaction
          X = SELECT tgt
              FROM X:src - (User_Transfer_Transaction>:e) - Transaction:tgt
              WHERE tgt.@min_right_dist < GSQL_INT_MAX//tgt must be touched in the above the negative search
                AND tgt.ts >= @@min_src_send_time 
                AND src.@min_left_dist < GSQL_INT_MAX 
                AND tgt.@min_left_dist == GSQL_INT_MAX
              ACCUM tgt.@min_left_dist += src.@min_left_dist + 1               
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
          END;
  
          // From Transaction to User
          X = SELECT tgt
              FROM X:src - (<User_Receive_Transaction:e) - User:tgt
              WHERE tgt.@min_right_dist < GSQL_INT_MAX//tgt must be touched in the above the negative search
                AND src.@min_left_dist < GSQL_INT_MAX 
                // Only when tgt is not left visited, update the distance info
                AND tgt.@min_left_dist == GSQL_INT_MAX
              ACCUM tgt.@min_left_dist += src.@min_left_dist + 1               
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END
              HAVING tgt != source_id;
      END;

      IF Y.size() > 0 THEN
          // From User to Transaction
          Y = SELECT tgt
              FROM Y:src - (User_Receive_Transaction>:e) - Transaction:tgt
              WHERE tgt.@min_left_dist < GSQL_INT_MAX//tgt must be touched in the above positive search
                AND tgt.ts <= @@max_src_receive_time 
                AND src.@min_right_dist < GSQL_INT_MAX
                AND tgt.@min_right_dist == GSQL_INT_MAX
              ACCUM tgt.@min_right_dist += src.@min_right_dist + 1
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END;
          // From Transaction to User
          Y = SELECT tgt
              FROM Y:src - (<User_Transfer_Transaction:e) - User:tgt
              WHERE tgt.@min_left_dist < GSQL_INT_MAX//tgt must be touched in the above positive search
                AND src.@min_right_dist < GSQL_INT_MAX 
                // Only when tgt is not left visited, update the distance info
                AND tgt.@min_right_dist == GSQL_INT_MAX
              ACCUM tgt.@min_right_dist += src.@min_right_dist + 1               
              POST-ACCUM
                CASE WHEN tgt.@min_left_dist < GSQL_INT_MAX 
                  AND tgt.@min_right_dist < GSQL_INT_MAX
                  AND tgt.@min_left_dist + tgt.@min_right_dist <= 2 * STEP_HIGH_LIMIT
                THEN
                  tgt.@is_valid = TRUE
              END
              HAVING tgt != source_id;
      END;
      STEP = STEP + 1;
  END;

  // 3. Start valid path traversal and circle detection
  STEP = 0;
  // Reset X as Seed
  X = Seed;
  WHILE STEP <= STEP_HIGH_LIMIT DO
      // From User to Transaction
      X = SELECT tgt
          FROM X:src - (User_Transfer_Transaction>:e) - Transaction:tgt
          WHERE tgt.@is_valid == TRUE
          ACCUM
            INT ts = tgt.ts,
            CASE WHEN src.@edge_tuple_list.size() == 0// If X is Seed, then only send edge over
              THEN 
                tgt.@new_edge_tuple_list += [Edge_Tuple(e, src, tgt.amount, ts)]
              ELSE
                FOREACH path in src.@edge_tuple_list DO
                  tgt.@new_edge_tuple_list += path + [Edge_Tuple(e, src, tgt.amount, ts)]
                END
              END,
            // Reset receive_new_path as false
            tgt.@receive_new_path = FALSE
          POST-ACCUM
            CASE WHEN tgt.@new_edge_tuple_list.size() > 0
              THEN 
                tgt.@edge_tuple_list = tgt.@new_edge_tuple_list,
                tgt.@receive_new_path = TRUE,
                tgt.@new_edge_tuple_list.clear()
              END
          HAVING tgt.@receive_new_path == TRUE;

      // From Transaction to User
      X = SELECT tgt
          FROM X:src - (<User_Receive_Transaction:e) - User:tgt
          WHERE tgt.@is_valid == TRUE
          ACCUM
            FOREACH path in src.@edge_tuple_list DO
              CASE WHEN tgt == source_id OR (NOT PathContainsV(path, tgt))
                THEN
                  tgt.@new_edge_tuple_list += path + [Edge_Tuple(e, src, src.amount, src.ts)]
                END
              END,
              // Reset receive_new_path as false
              tgt.@receive_new_path = FALSE
          POST-ACCUM
            CASE WHEN tgt.@new_edge_tuple_list.size() > 0
              THEN
                CASE WHEN tgt == source_id// If it backs to start point, there is a valid circle
                  THEN
                    /* STEP + 1 gives the current updated step
                    it is the number of User -> User steps for current paths 
                    (there maybe multiple paths but all of them should have the same length)*/
                    CASE WHEN STEP + 1 >= STEP_LOW_LIMIT
                      THEN 
                        @@circle_edge_tuples_list += tgt.@new_edge_tuple_list
                      END
                      // Else, overwrite the old @edge_tuple_list, since the old one is already used
                      ELSE tgt.@edge_tuple_list = tgt.@new_edge_tuple_list
                END,
                tgt.@receive_new_path = TRUE,
                tgt.@new_edge_tuple_list.clear()
            END
          HAVING tgt.@receive_new_path == TRUE AND tgt != source_id;
          STEP = STEP + 1;
  END;
  
  /* Print JSON only if it is directly called or else return @@circle_edge_tuples_list directly
  use the drainRatio to filter out invalid paths
  store all valid vertices into @@vertex_set and all paths into @@circle_paths_list*/
  
  PRINT @@circle_edge_tuples_list;
}