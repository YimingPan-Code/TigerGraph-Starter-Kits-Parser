CREATE QUERY same_receiver_sender(vertex<Transaction> transaction) FOR GRAPH AntiFraud syntax v2 {
  /* 
  This query is used to find out whether a user conduct fraudulent transaction for themselves 
  via fake accounts.
 
  Given an input transaction "transaction", return true when its receiver and sender are connected via 
  Device_Token and Payment_Instrument within 4 steps.    

  Sample input:
  transaction: any integer between 1 and 1000.
  */
  OrAccum<BOOL> @from_receiver, @from_sender;
  OrAccum<BOOL> @@is_same;
  SetAccum<EDGE> @@edge_set;

  Start (ANY) = {transaction};

  // Prep: Get the sender and receiver
  Start = SELECT t 
    FROM Start:s-((<User_Receive_Transaction_Rev|<User_Transfer_Transaction_Rev):e)-:t
    ACCUM
      // Mark the sender and receiver according to the edge type
      CASE WHEN e.type == "User_Receive_Transaction_Rev" THEN
        t.@from_receiver += true
      ELSE
        t.@from_sender += true
      END,
        @@edge_set += e;

  // Traverse for 4 steps, or the paths of sender and receiver meets each other
  WHILE Start.size() > 0 AND @@is_same == false LIMIT 4 DO
    Start = SELECT t 
      FROM Start:s-((User_to_Device|User_to_Payment):e)-:t
      // Do not traverse the vertexes that were visited
      WHERE t.@from_receiver == false AND t.@from_sender == false
      ACCUM 
        t.@from_receiver += s.@from_receiver,
        t.@from_sender += s.@from_sender,
        @@edge_set += e
      POST-ACCUM
        // When two paths meets in the middle
        CASE WHEN t.@from_receiver == true AND t.@from_sender THEN
          @@is_same += true
        END;
  END;

  // Output the result
  PRINT @@is_same;
  PRINT @@edge_set;
}